import mongoose from "mongoose";

const eventSchema = new mongoose.Schema(
  {
    // Basic Information
    title: {
      type: String,
      required: [true, "Event title is required"],
      trim: true,
    },
    description: {
      type: String,
      required: [true, "Event description is required"],
      trim: true,
    },
    destination: {
      type: String,
      required: [true, "Destination is required"],
      trim: true,
    },

    // Date Information
    startDate: {
      type: Date,
      required: [true, "Start date is required"],
    },
    endDate: {
      type: Date,
      required: [true, "End date is required"],
    },
    duration: {
      type: Number, // in days
      min: 1,
    },

    // Event Type & Classification
    eventType: {
      type: String,
      enum: ["booking-linked", "standalone", "blocked"],
      default: "standalone",
    },
    bookingType: {
      type: String,
      enum: ["hotel", "package", "property"],
      required: function () {
        return this.eventType === "booking-linked";
      },
    },

    // Booking Link (for booking-linked events)
    linkedBooking: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Booking",
      sparse: true,
    },
    autoGenerated: {
      type: Boolean,
      default: false,
    },

    // Standalone Event Specific Fields
    maxBookings: {
      type: Number,
      min: 1,
      required: function () {
        return this.eventType === "standalone";
      },
    },
    currentBookings: {
      type: Number,
      default: 0,
      min: 0,
    },
    bookings: [
      {
        type: mongoose.Schema.Types.ObjectId,
        ref: "Booking",
      },
    ],

    // Location Details
    startLocation: {
      type: String,
      trim: true,
      required: function () {
        return this.eventType === "standalone";
      },
    },
    endLocation: {
      type: String,
      trim: true,
      required: function () {
        return this.eventType === "standalone";
      },
    },

    // Status Management
    status: {
      type: String,
      enum: ["active", "inactive", "draft", "cancelled", "completed"],
      default: "active",
    },

    // Visual/Display Properties
    color: {
      type: String,
      default: function () {
        if (this.eventType === "booking-linked") {
          switch (this.bookingType) {
            case "hotel":
              return "#3B82F6"; // Blue
            case "package":
              return "#10B981"; // Green
            case "property":
              return "#F59E0B"; // Amber
            default:
              return "#6B7280"; // Gray
          }
        }
        return "#8B5CF6"; // Purple for standalone
      },
    },
    priority: {
      type: String,
      enum: ["low", "medium", "high"],
      default: "medium",
    },

    // References to related entities
    hotel: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Hotel",
    },
    package: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Package",
    },
    property: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Property",
    },
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },

    // Additional Information
    notes: {
      type: String,
      trim: true,
    },
    internalNotes: {
      type: String,
      trim: true,
    },

    // Metadata
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Indexes for better query performance
eventSchema.index({ startDate: 1, endDate: 1 });
eventSchema.index({ eventType: 1 });
eventSchema.index({ linkedBooking: 1 }, { sparse: true });
eventSchema.index({ status: 1 });
eventSchema.index({ bookingType: 1 });
eventSchema.index({ createdAt: -1 });
eventSchema.index({ startDate: 1, status: 1 });

// Virtual for available slots (standalone events only)
eventSchema.virtual("availableSlots").get(function () {
  if (this.eventType === "standalone" && this.maxBookings) {
    return this.maxBookings - (this.currentBookings || 0);
  }
  return null;
});

// Virtual for is fully booked
eventSchema.virtual("isFullyBooked").get(function () {
  if (this.eventType === "standalone" && this.maxBookings) {
    return this.currentBookings >= this.maxBookings;
  }
  return false;
});

// Virtual for is past event
eventSchema.virtual("isPast").get(function () {
  return this.endDate < new Date();
});

// Virtual for is upcoming
eventSchema.virtual("isUpcoming").get(function () {
  return this.startDate > new Date();
});

// Virtual for is current/ongoing
eventSchema.virtual("isCurrent").get(function () {
  const now = new Date();
  return this.startDate <= now && this.endDate >= now;
});

// Pre-save middleware
eventSchema.pre("save", function (next) {
  // Calculate duration if not provided
  if (this.startDate && this.endDate && !this.duration) {
    const diffTime = Math.abs(this.endDate - this.startDate);
    this.duration = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  // For standalone events, ensure currentBookings doesn't exceed maxBookings
  if (this.eventType === "standalone" && this.maxBookings) {
    if (this.currentBookings > this.maxBookings) {
      return next(new Error("Current bookings cannot exceed maximum bookings"));
    }
  }

  // Update currentBookings based on bookings array length
  if (this.eventType === "standalone" && this.bookings) {
    this.currentBookings = this.bookings.length;
  }

  next();
});

// Pre-validate middleware
eventSchema.pre("validate", function (next) {
  // Validate end date is after start date
  if (this.endDate <= this.startDate) {
    return next(new Error("End date must be after start date"));
  }

  // Validate booking-linked events have proper references
  if (this.eventType === "booking-linked" && !this.linkedBooking) {
    return next(
      new Error("Booking-linked events must have a linkedBooking reference")
    );
  }

  next();
});

// Instance method to cancel event (and linked booking if applicable)
eventSchema.methods.cancelEvent = async function (cancelledBy, reason) {
  this.status = "cancelled";

  // If this is a booking-linked event, cancel the associated booking
  if (this.linkedBooking) {
    const Booking = mongoose.model("Booking");
    const booking = await Booking.findById(this.linkedBooking);
    if (booking) {
      await booking.cancelBooking(cancelledBy, reason);
    }
  }

  return this.save();
};

// Instance method to complete event
eventSchema.methods.completeEvent = function () {
  this.status = "completed";
  return this.save();
};

// Instance method to add booking to standalone event
eventSchema.methods.addBooking = function (bookingId) {
  if (this.eventType !== "standalone") {
    throw new Error("Only standalone events can have multiple bookings");
  }

  if (this.isFullyBooked) {
    throw new Error("Event is fully booked");
  }

  if (!this.bookings.includes(bookingId)) {
    this.bookings.push(bookingId);
    this.currentBookings = this.bookings.length;
  }

  return this.save();
};

// Instance method to remove booking from standalone event
eventSchema.methods.removeBooking = function (bookingId) {
  if (this.eventType !== "standalone") {
    throw new Error("Only standalone events can have multiple bookings");
  }

  this.bookings = this.bookings.filter(
    (id) => id.toString() !== bookingId.toString()
  );
  this.currentBookings = this.bookings.length;

  return this.save();
};

// Static method to create event from booking
eventSchema.statics.createFromBooking = async function (booking) {
  // Determine the title based on booking type
  let title = "";
  let referencedItem = null;

  if (booking.bookingType === "hotel" && booking.hotel) {
    const Hotel = mongoose.model("Hotel");
    referencedItem = await Hotel.findById(booking.hotel);
    title = `Hotel Booking - ${referencedItem?.name || "Unknown Hotel"}`;
  } else if (booking.bookingType === "package" && booking.package) {
    const Package = mongoose.model("Package");
    referencedItem = await Package.findById(booking.package);
    title = `Package - ${referencedItem?.title || "Unknown Package"}`;
  } else if (booking.bookingType === "property" && booking.property) {
    const Property = mongoose.model("Property");
    referencedItem = await Property.findById(booking.property);
    title = `Property Booking - ${referencedItem?.name || "Unknown Property"}`;
  }

  const event = new this({
    title,
    description:
      referencedItem?.description ||
      `${booking.bookingType} booking for ${booking.guestDetails.firstName} ${booking.guestDetails.lastName}`,
    destination: referencedItem?.location || booking.guestDetails.country || "",
    startDate: booking.checkIn,
    endDate: booking.checkOut,
    duration: booking.duration,
    eventType: "booking-linked",
    bookingType: booking.bookingType,
    linkedBooking: booking._id,
    autoGenerated: true,
    status: booking.status === "cancelled" ? "cancelled" : "active",
    hotel: booking.hotel,
    package: booking.package,
    property: booking.property,
    user: booking.user,
    notes: `Booking Reference: ${booking.bookingReference}`,
  });

  return event.save();
};

// Static method to find upcoming events
eventSchema.statics.findUpcoming = function (filters = {}) {
  return this.find({
    startDate: { $gt: new Date() },
    status: { $in: ["active", "confirmed"] },
    ...filters,
  }).sort({ startDate: 1 });
};

// Static method to find past events
eventSchema.statics.findPast = function (filters = {}) {
  return this.find({
    endDate: { $lt: new Date() },
    ...filters,
  }).sort({ endDate: -1 });
};

// Static method to find current events
eventSchema.statics.findCurrent = function (filters = {}) {
  const now = new Date();
  return this.find({
    startDate: { $lte: now },
    endDate: { $gte: now },
    status: { $in: ["active", "confirmed"] },
    ...filters,
  });
};

// Static method to get events by date range
eventSchema.statics.getByDateRange = function (
  startDate,
  endDate,
  filters = {}
) {
  return this.find({
    $or: [
      // Events that start within the range
      {
        startDate: { $gte: startDate, $lte: endDate },
      },
      // Events that end within the range
      {
        endDate: { $gte: startDate, $lte: endDate },
      },
      // Events that span the entire range
      {
        startDate: { $lte: startDate },
        endDate: { $gte: endDate },
      },
    ],
    ...filters,
  }).sort({ startDate: 1 });
};

// Static method to get events for calendar view
eventSchema.statics.getCalendarEvents = function (month, year) {
  const startDate = new Date(year, month - 1, 1);
  const endDate = new Date(year, month, 0, 23, 59, 59);

  return this.find({
    $or: [
      { startDate: { $gte: startDate, $lte: endDate } },
      { endDate: { $gte: startDate, $lte: endDate } },
      { startDate: { $lte: startDate }, endDate: { $gte: endDate } },
    ],
  })
    .populate("linkedBooking", "bookingReference status guestDetails")
    .populate("user", "firstName lastName email")
    .populate("hotel", "name location")
    .populate("package", "title")
    .populate("property", "name location")
    .sort({ startDate: 1 });
};

// Static method to get event statistics
eventSchema.statics.getEventStats = function () {
  return this.aggregate([
    {
      $group: {
        _id: null,
        totalEvents: { $sum: 1 },
        activeEvents: {
          $sum: { $cond: [{ $eq: ["$status", "active"] }, 1, 0] },
        },
        completedEvents: {
          $sum: { $cond: [{ $eq: ["$status", "completed"] }, 1, 0] },
        },
        cancelledEvents: {
          $sum: { $cond: [{ $eq: ["$status", "cancelled"] }, 1, 0] },
        },
        bookingLinkedEvents: {
          $sum: { $cond: [{ $eq: ["$eventType", "booking-linked"] }, 1, 0] },
        },
        standaloneEvents: {
          $sum: { $cond: [{ $eq: ["$eventType", "standalone"] }, 1, 0] },
        },
      },
    },
  ]);
};

const Event = mongoose.model("Event", eventSchema);

export default Event;
